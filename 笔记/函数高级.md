# 函数高级
> **prototype**
> 1. 函数的`prototype`属性：
> 每个函数都有一个`prototype`属性，它默认指向一个Object空对象（即为原型对象）
> 原型对象中有一个属性`constructor`，它指向函数对象
> 2. 给原型对象添加属性（一般都是方法）
> 作用：函数的所有实例对象自动拥有原型中的属性（方法）
---
> **显式原型与隐式原型**
> 1. 每个函数function都有一个`prototype`，即显式原型（显式原型属性）
> 2. 每个实例对象都有一个`_proto_`，可称为隐式原型（隐式原型属性），但实例对象没有显式原型
> 3. 对象的隐式原型的值为其对应构造函数的显式原型的值
> 4. 在调用方法时，对象会现在实例对象本身上查找，若没有则会在隐式原型（构造函数的显式原型）上查找
> 5. 总结：
>      - 函数的`prototype`属性：在定义函数时自动添加，默认值是一个Object空对象
>      - 对象的_proto_属性：创建对象时自动添加，默认值为构造函数的`prototype`属性值
>      - 程序员能直接操作显式原型，但不能操作隐式原型（ES6之前）
---
> **原型链**
> - 访问一个对象的属性时：
>   - 先在自身属性中查找，找到返回
>   - 如果没有，再沿着`_proto_`这条链上向上查找，找到返回
>   - 如果最终没有找到，返回undefined
> - 别名：隐式原型链
>   - 作用：查找对象的属性（方法）
> - 函数的显式原型指向的对象默认是空的Object实例对象（Object实例对象的显式原型为null）
> - 所有函数都是Function的实例（包括function），Function的显式原型是函数Object的实例，所以：
>   `Function.prototype._proto_ == Object.prototype`
---
> 1. 变量提升
> - 通过var定义（声明）的变量，在定义语句之前就可以访问到，值为undefined
> 2. 函数声明提升
> - 通过function声明的函数，在之前就可以直接调用，值为函数定义（对象）
---
> **执行上下文**
> 1. 代码分类（位置）
>       - 全局代码
>       - 函数（局部）代码
> 2. 全局执行上下文
>       - 在执行全局代码前将window确定为全局执行上下文
>       - 对全局数据进行预处理
>           - var定义的全局变量==>undefined，添加为window属性
>           - function声明的全局函数==>赋值（function），添加为window的方法
>       - 开始执行全局代码
> 3. 函数执行上下文
>       - 在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象
>       - 对局部数据进行预处理
>           - 形参变量==>复制（实参）==>添加为执行上下文的属性
>           - arguments==>复制（实参列表），添加为执行上下文的属性
>           - var定义的局部变量==>undefined，添加为执行上下文的属性
>           - function声明的函数==>赋值（function），添加为执行上下文的方法
>           - this==>赋值（调用函数的对象）
>       - 开始执行函数体代码
---
> **作用域**
> 1. 理解
>       - 就是一块“地盘”，一个代码段所在的区域
>       - 他是静态的（相对于上下文对象），在编写代码时就确定了
> 2. 分类
>       - 全局作用域
>       - 函数作用域
>       - 没有块作用域（ES6有）
> 3. 作用
>       - 隔离变量，不同作用域下变量名称不会有冲突
> 
> **作用域与执行上下文**
> 1. 区别1
>       - 全作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了，而不是在函数调用书
>       - 全局执行上下文环境是在全局作用域确定之后，js代码马上执行之前创建
>       - 函数执行上下文是在调用函数时，函数体代码执行之前创建
> 2. 区别2
>       - 作用域是静态的，只要函数定义好了就一直存在，且不会再变化
>       - 执行上下文是动态的，调用函数时创建，函数调用结束时上下文环境就会被自动释放
> 3. 联系
>       - 执行上下文环境（对象）是从属于所在的作用域
>       - 全局上下文环境==>全局作用域
>       - 函数上下文==>对应的函数作用域
---
> **闭包**
> 1. 闭包的理解
> - 如何产生闭包？
>   - 当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量（函数）时，就产生了闭包
> - 闭包到底是什么？
>   - 理解一：闭包时嵌套的内部函数（绝大部分人）
>   - 理解二：包含被引用变量（函数）的对象（极少数人）
>   - 注意：闭包存在于嵌套的内部函数中
> - 产生闭包的条件？
>   - 函数嵌套
>   - 内部函数引用了外部函数的数据（变量/函数）
> - 常见的闭包
>   - 将函数作为另一个函数的返回值
>   - 将函数作为实参传递给另一个函数调用
> - 闭包的作用
>   1. 使用函数内部的变量在函数执行完毕后，仍然存活在内存中（延长了局部变量的生命周期）
>   2. 让函数外部可以操作（读写）到函数内部的数据（变量/函数）
> - 闭包的生命周期
>   - 产生：在嵌套内部函数定义执行完时就产生了（不是在调用）
>   - 死亡：在嵌套的内部函数称为垃圾对象时
> - 闭包的应用2：定义JS模块
>   - 具有特定功能的js文件
>   - 将所有的数据和功能都封装在一个函数的内部（私有的）
>   - 只向外暴露一个包含n个方法的对象或函数
>   - 模块的使用者只需要通过模块暴露的对象调用方法来实现对应的功能
> - 闭包的缺点
>   - 函数执行完毕后，函数内的局部变量没有释放，占用内存时间会变长
>   - 容易造成内存泄漏
> - 解决方法
>   - 能不用闭包就不用
>   - 及时释放
> - 内存溢出
>   - 一种程序运行出现的错误
>   - 当程序运行需要的内存超过了剩余的内存时，就出抛出内存溢出的错误
> - 内存泄漏
>   - 占用的内存没有及时释放
>   - 内存泄漏积累多了就容易导致内存溢出
>   - 常见的内存泄漏：
>       - 意外的全局变量
>       - 没有及时清理的计时器或回调函数
>       - 闭包