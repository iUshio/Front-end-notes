{"template":"default","theme":"fresh-blue","version":"1.4.43","root":{"data":{"id":"MID-72d4di2j76hdhholmn139gls4u","text":"JS高级"},"children":[{"data":{"id":"MID-26b07jl54rnq0cu7giq38chp7p","text":"基础总结深入","priority":1},"children":[{"data":{"id":"MID-4htgv5fgqpj3h9tcfnagf7iquj","text":"数据类型","note":"1. 分类(2大类)  * 基本(值)类型    * Number: 任意数值    * String: 任意文本    * Boolean: true/false    * undefined: undefined    * null: null  * 对象(引用)类型    * Object: 一般对象类型    * Array: 特别的对象类型(下标/内部数据有序)    * Function: 特别的对象类型(可执行)2. 判断  * typeof:    * 可以区别: 数值, 字符串, 布尔值, undefined, function    * 不能区别: null与对象, 一般对象与数组  * instanceof    * 专门用来判断对象数据的类型: Object, Array与Function  * ===    * 可以判断: undefined和null\r\n1. 分类(2大类)\r\n  * 基本(值)类型\r\n    * Number: 任意数值\r\n    * String: 任意文本\r\n    * Boolean: true/false\r\n    * undefined: undefined\r\n    * null: null\r\n  * 对象(引用)类型\r\n    * Object: 一般对象类型\r\n    * Array: 特别的对象类型(下标/内部数据有序)\r\n    * Function: 特别的对象类型(可执行)\r\n2. 判断\r\n  * typeof:\r\n    * 可以区别: 数值, 字符串, 布尔值, undefined, function\r\n    * 不能区别: null与对象, 一般对象与数组\r\n  * instanceof\r\n    * 专门用来判断对象数据的类型: Object, Array与Function\r\n  * ===\r\n    * 可以判断: undefined和null"},"children":[{"data":{"id":"MID-65e3s3npu21mn6fv8t8thdouc6","text":"1. 分类"},"children":[]},{"data":{"id":"MID-1t3lqlds5k0orar93h85ot5uv3","text":"2. 判断"},"children":[]},{"data":{"id":"MID-7ovnoobrf2rm0arvmh6errpa32","text":"相关问题","note":"1. undefined与null的区别?  * undefined代表变量没有赋值  * null: 代表变量赋值了, 只是值为null2. 什么时候将变量赋值为null?  * 初始化赋值: 将要作为引用变量使用, 但对象还没有确定  * 结束时: 将变量指向的对象成为垃圾对象3. 理解变量类型与数据类型?  * js的变量本身是没有类型的, 变量的类型实际上是变量内存中数据的类型  * 变量类型:    * 基本类型: 保存基本类型数据的变量    * 引用类型: 保存对象地址值的变量  * 数据对象    * 基本类型    * 对象类型\r\n1. undefined与null的区别?\r\n  * undefined代表变量没有赋值\r\n  * null: 代表变量赋值了, 只是值为null\r\n2. 什么时候将变量赋值为null?\r\n  * 初始化赋值: 将要作为引用变量使用, 但对象还没有确定\r\n  * 结束时: 将变量指向的对象成为垃圾对象\r\n3. 理解变量类型与数据类型?\r\n  * js的变量本身是没有类型的, 变量的类型实际上是变量内存中数据的类型\r\n  * 变量类型:\r\n    * 基本类型: 保存基本类型数据的变量\r\n    * 引用类型: 保存对象地址值的变量\r\n  * 数据对象\r\n    * 基本类型\r\n    * 对象类型"},"children":[{"data":{"id":"MID-4bi1r87tacgkjm0ut6gdkdgrf1","text":"1. undefined与null的区别?"},"children":[]},{"data":{"id":"MID-7od6b8ntnvl0n1r3m26tsj3ain","text":"2. 什么时候将变量赋值为null?"},"children":[]},{"data":{"id":"MID-4d1qkavsu2qkcm02un19eapo0n","text":"3. 严格区别变量类型与数据类型?"},"children":[]}]}]},{"data":{"id":"MID-0supluur1b7egeuujaij0qh1cj","text":"数据, 变量与内存","note":"1. 什么是数据?  * 存储于内存中代表特定信息的'东东', 本质就是0101二进制  * 具有可读和可传递的基本特性  * 万物(一切)皆数据, 函数也是数据  * 程序中所有操作的目标: 数据    * 算术运算    * 逻辑运算    * 赋值    * 调用函数传参    ...2. 什么是内存?  * 内存条通电后产生的存储空间(临时的)  * 产生和死亡: 内存条(集成电路板)==>通电==>产生一定容量的存储空间==>存储各种数据==>断电==>内存全部消失  * 内存的空间是临时的, 而硬盘的空间是持久的  * 分配内存: 声明变量和函数或创建对象时, JS引擎会自动为此分配一定大小的内存来存放对应的数据  * 释放内存: 清空内存中的数据, 标识内存可以再分配使用(内存不释放就不能复用)    * 自动释放: 栈空间的局部变量    * 垃圾回调器回调: 堆空间的垃圾对象  * 一块内存包含2个数据    * 内部存储的数据(一般数据/地址数据)    * 内存地址值数据  * 内存分类    * 栈: 全局变量, 局部变量 (空间较小)    * 堆: 对象 (空间较大)3. 什么是变量?  * 值可以变化的量, 由变量名与变量值组成  * 一个变量对应一块小内存, 变量名用来查找到内存, 变量值就是内存中保存的内容4. 内存,数据, 变量三者之间的关系  * 内存是一个容器, 用来存储程序运行需要操作的数据  * 变量是内存的标识, 我们通过变量找到对应的内存, 进而操作(读/写)内存中的数据\r\n1. 什么是数据?\r\n  * 存储于内存中代表特定信息的'东东', 本质就是0101二进制\r\n  * 具有可读和可传递的基本特性\r\n  * 万物(一切)皆数据, 函数也是数据\r\n  * 程序中所有操作的目标: 数据\r\n    * 算术运算\r\n    * 逻辑运算\r\n    * 赋值\r\n    * 调用函数传参\r\n    ...\r\n2. 什么是内存?\r\n  * 内存条通电后产生的存储空间(临时的)\r\n  * 产生和死亡: 内存条(集成电路板)==>通电==>产生一定容量的存储空间==>存储各种数据==>断电==>内存全部消失\r\n  * 内存的空间是临时的, 而硬盘的空间是持久的\r\n  * 分配内存: 声明变量和函数或创建对象时, JS引擎会自动为此分配一定大小的内存来存放对应的数据\r\n  * 释放内存: 清空内存中的数据, 标识内存可以再分配使用(内存不释放就不能复用)\r\n    * 自动释放: 栈空间的局部变量\r\n    * 垃圾回调器回调: 堆空间的垃圾对象\r\n  * 一块内存包含2个数据\r\n    * 内部存储的数据(一般数据/地址数据)\r\n    * 内存地址值数据\r\n  * 内存分类\r\n    * 栈: 全局变量, 局部变量 (空间较小)\r\n    * 堆: 对象 (空间较大)\r\n3. 什么是变量?\r\n  * 值可以变化的量, 由变量名与变量值组成\r\n  * 一个变量对应一块小内存, 变量名用来查找到内存, 变量值就是内存中保存的内容\r\n4. 内存,数据, 变量三者之间的关系\r\n  * 内存是一个容器, 用来存储程序运行需要操作的数据\r\n  * 变量是内存的标识, 我们通过变量找到对应的内存, 进而操作(读/写)内存中的数据"},"children":[{"data":{"id":"MID-4vru5q57f74d00mer2iud54t00","text":"1. 什么是数据?"},"children":[]},{"data":{"id":"MID-29i9bmrnbps2971763cc68lcfa","text":"2. 什么是内存?"},"children":[{"data":{"id":"MID-3phj148uvucflenqnnpljgur27","text":"undefined","image":"xap:resources/6ri84qfjjv05fnsqrps4rodg51.png","imageSize":{}},"children":[]}]},{"data":{"id":"MID-249hot4fsdkiitii1dj5m4l3m7","text":"3. 什么是变量?"},"children":[]},{"data":{"id":"MID-7fpj3rn4gnv0oivomeaiuf0crs","text":"4. 内存,数据, 变量三者之间的关系"},"children":[]},{"data":{"id":"MID-7el8v4efcg4eijtuq35b6ttiic","text":"相关问题","note":"1. 问题1: var a = xxx, a内存中到底保存的是什么?  * xxx是一个基本数据  * xxx是一个对象  * xxx是一个变量2. 关于引用变量赋值问题  * 2个引用变量指向同一个对象, 通过一个引用变量修改对象内部数据, 另一个引用变量也看得见  * 2个引用变量指向同一个对象,让一个引用变量指向另一个对象, 另一个引用变量还是指向原来的对象3. 问题: 在js调用函数时传递变量参数时, 是值传递还是引用传递?  * 只有值传递, 没有引用传递, 传递的都是变量的值, 只是这个值可能是基本数据, 也可能是地址(引用)数据  *  如果后一种看成是引用传递, 那就值传递和引用传递都可以有4. 问题: JS引擎如何管理内存?  1. 内存生命周期    1). 分配需要的内存    2). 使用分配到的内存    3). 不需要时将其释放/归还  2. 释放内存    * 为执行函数分配的栈空间内存: 函数执行完自动释放    * 存储对象的堆空间内存: 当内存没有引用指向时, 对象成为垃圾对象, 垃圾回收器后面就会回收释放此内存\r\n1. 问题1: var a = xxx, a内存中到底保存的是什么?\r\n  * xxx是一个基本数据\r\n  * xxx是一个对象\r\n  * xxx是一个变量\r\n\r\n2. 关于引用变量赋值问题\r\n  * 2个引用变量指向同一个对象, 通过一个引用变量修改对象内部数据, 另一个引用变量也看得见\r\n  * 2个引用变量指向同一个对象,让一个引用变量指向另一个对象, 另一个引用变量还是指向原来的对象\r\n\r\n3. 问题: 在js调用函数时传递变量参数时, 是值传递还是引用传递?\r\n  * 只有值传递, 没有引用传递, 传递的都是变量的值, 只是这个值可能是基本数据, 也可能是地址(引用)数据\r\n  *  如果后一种看成是引用传递, 那就值传递和引用传递都可以有\r\n\r\n4. 问题: JS引擎如何管理内存?\r\n  1. 内存生命周期\r\n    1). 分配需要的内存\r\n    2). 使用分配到的内存\r\n    3). 不需要时将其释放/归还\r\n  2. 释放内存\r\n    * 为执行函数分配的栈空间内存: 函数执行完自动释放\r\n    * 存储对象的堆空间内存: 当内存没有引用指向时, 对象成为垃圾对象, 垃圾回收器后面就会回收释放此内存"},"children":[{"data":{"id":"MID-68rk7h6er7n50679v6q61mfue7","text":"关于赋值与内存的问题?"},"children":[]},{"data":{"id":"MID-3h7417rbh5pvefs7e8rb915vjk","text":"关于引用变量赋值问题?"},"children":[]},{"data":{"id":"MID-6svqfot8j03ro27tvtkkoun2ge","text":"关于数据传递问题?"},"children":[]},{"data":{"id":"MID-71uvi6pl1tadgde2c2f0oqaa1c","text":"JS引擎如何管理内存?"},"children":[]}]}]},{"data":{"id":"MID-2dkjtiko3srad5f78afibnusqq","text":"对象","note":"1. 什么是对象?  * 代表现实中的某个事物, 是该事物在编程中的抽象  * 多个数据的集合体(封装体)  * 用于保存多个数据的容器2. 为什么要用对象?  * 便于对多个数据进行统一管理3. 对象的组成  * 属性    * 代表现实事物的状态数据    * 由属性名和属性值组成    * 属性名都是字符串类型, 属性值是任意类型  * 方法    * 代表现实事物的行为数据    * 是特别的属性==>属性值是函数4. 如何访问对象内部数据?  * .属性名: 编码简单, 但有时不能用  * ['属性名']: 编码麻烦, 但通用\r\n1. 什么是对象?\r\n  * 代表现实中的某个事物, 是该事物在编程中的抽象\r\n  * 多个数据的集合体(封装体)\r\n  * 用于保存多个数据的容器\r\n2. 为什么要用对象?\r\n  * 便于对多个数据进行统一管理\r\n3. 对象的组成\r\n  * 属性\r\n    * 代表现实事物的状态数据\r\n    * 由属性名和属性值组成\r\n    * 属性名都是字符串类型, 属性值是任意类型\r\n  * 方法\r\n    * 代表现实事物的行为数据\r\n    * 是特别的属性==>属性值是函数\r\n4. 如何访问对象内部数据?\r\n  * .属性名: 编码简单, 但有时不能用\r\n  * ['属性名']: 编码麻烦, 但通用\r\n"},"children":[{"data":{"id":"MID-1eli56vkk9flnjjj2lgh6i6v2b","text":"1. 什么是对象?"},"children":[]},{"data":{"id":"MID-2o8toq29oiurc31ai3l0bne49v","text":"2. 为什么要用对象?"},"children":[]},{"data":{"id":"MID-43p852c06hkqi9g9bce0lmuri4","text":"3. 对象的组成"},"children":[]},{"data":{"id":"MID-30ikjjbusvuou1bup20l3ufavu","text":"4. 如何访问对象内部数据?"},"children":[]},{"data":{"id":"MID-31tvh4c7g1kl883vhafqdngb4m","text":"相关问题","note":"什么时候必须使用['属性名']的方式访问对象内部数据?  * 属性名不是合法的标识名  * 属性名不确定\r\n什么时候必须使用['属性名']的方式访问对象内部数据?\r\n  * 属性名不是合法的标识名\r\n  * 属性名不确定"},"children":[{"data":{"id":"MID-4nlqd54lrg65rldla6pmv28uuc","text":"什么时候必须使用['属性名']的方式?"},"children":[]}]}]},{"data":{"id":"MID-11qcifpgcl1h215dpdgklbvoq4","text":"函数","note":"1. 什么是函数?  * 具有特定功能的n条语句的封装体  * 只有函数是可执行的, 其它类型的数据是不可执行的  * 函数也是对象2. 为什么要用函数?  * 提高代码复用  * 便于阅读和交流3. 如何定义函数?  * 函数声明  * 表达式4. 调用(执行)函数  * test()  * new test()  * obj.test()  * test.call/apply(obj)\r\n1. 什么是函数?\r\n  * 具有特定功能的n条语句的封装体\r\n  * 只有函数是可执行的, 其它类型的数据是不可执行的\r\n  * 函数也是对象\r\n2. 为什么要用函数?\r\n  * 提高代码复用\r\n  * 便于阅读和交流\r\n3. 如何定义函数?\r\n  * 函数声明\r\n  * 表达式\r\n4. 调用(执行)函数\r\n  * test()\r\n  * new test()\r\n  * obj.test()\r\n  * test.call/apply(obj)"},"children":[{"data":{"id":"MID-06n5dp4ncrocg80f088tkfnvfl","text":"1. 什么是函数?"},"children":[]},{"data":{"id":"MID-2sghr1ig2jg97ine7744dclt35","text":"2. 为什么要用函数?"},"children":[]},{"data":{"id":"MID-5uecn3gbblkm5rprtvbs8pkbig","text":"3. 如何定义函数?"},"children":[]},{"data":{"id":"MID-0vlqflse54a5lkjnnh8ujojqkg","text":"4. 如何调用(执行)函数?"},"children":[]},{"data":{"id":"MID-637pmlnnu1h6gd49stdas95upf","text":"5. 回调函数","note":"1. 什么函数才是回调函数?  * 你定义的  * 你没有直接调用  * 但最终它执行了(在特定条件或时刻)2. 常见的回调函数?  * DOM事件函数  * 定时器函数  * ajax回调函数(后面学)  * 生命周期回调函数(后面学)\r\n1. 什么函数才是回调函数?\r\n  * 你定义的\r\n  * 你没有直接调用\r\n  * 但最终它执行了(在特定条件或时刻)\r\n2. 常见的回调函数?\r\n  * DOM事件函数\r\n  * 定时器函数\r\n\r\n  * ajax回调函数(后面学)\r\n  * 生命周期回调函数(后面学)"},"children":[{"data":{"id":"MID-6kgntlkmqrpslkm5ln67slf8hs","text":"1. 什么函数才是回调函数?"},"children":[]},{"data":{"id":"MID-388llnvfkri9194358p74ocvsi","text":"2. 常见的回调函数?"},"children":[]}]},{"data":{"id":"MID-0ju6j4m58nupt5ihu4t55233rk","text":"6. IIEF","note":"1. 理解  * 全称: Immediately-Invoked Function Expression 立即调用函数表达式  * 别名: 匿名函数自调用2. 作用  * 隐藏内部实现  * 不污染外部命名空间\r\n1. 理解\r\n  * 全称: Immediately-Invoked Function Expression 立即调用函数表达式\r\n  * 别名: 匿名函数自调用\r\n2. 作用\r\n  * 隐藏内部实现\r\n  * 不污染外部命名空间"},"children":[{"data":{"id":"MID-1sb2j1m6dfolv45edilt15cn4u","text":"1. 理解"},"children":[]},{"data":{"id":"MID-6fneasrh7c93quhj4cvba9ran0","text":"2. 作用"},"children":[]}]},{"data":{"id":"MID-2qot6aapcfe4252eoeqk58ehkj","text":"7. 函数中的this","note":"function Person(color) {  // console.log(this)  this.color = color;  this.getColor = function () {    // console.log(this)    return this.color;  };  this.setColor = function (color) {   // console.log(this)    this.color = color;  };}Person(\"red\"); //this是谁?var p = new Person(\"yello\"); //this是谁?p.getColor(); //this是谁?var obj = {};p.setColor.call(obj, \"black\"); //this是谁?var test = p.setColor;test(); //this是谁?function fun1() {  function fun2() {    console.log(this);  }  fun2(); //this是谁?}fun1();\r\nfunction Person(color) {\r\n  // console.log(this)\r\n  this.color = color;\r\n  this.getColor = function () {\r\n    // console.log(this)\r\n    return this.color;\r\n  };\r\n  this.setColor = function (color) {\r\n   // console.log(this)\r\n    this.color = color;\r\n  };\r\n}\r\n\r\nPerson(\"red\"); //this是谁?\r\n\r\nvar p = new Person(\"yello\"); //this是谁?\r\n\r\np.getColor(); //this是谁?\r\n\r\nvar obj = {};\r\np.setColor.call(obj, \"black\"); //this是谁?\r\n\r\nvar test = p.setColor;\r\ntest(); //this是谁?\r\n\r\nfunction fun1() {\r\n  function fun2() {\r\n    console.log(this);\r\n  }\r\n\r\n  fun2(); //this是谁?\r\n}\r\nfun1();"},"children":[]}]}]},{"data":{"id":"MID-6u2npjmfst010046vvqj11ka86","text":"函数高级","priority":2},"children":[{"data":{"id":"MID-35e6sn28du5u9icoue5pgt877d","text":"原型与原型链"},"children":[{"data":{"id":"MID-67rj78qhotr7lvds6lsarkv1nu","text":"原型(prototype)","note":"1. 函数的prototype属性(图)  * 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)  * 原型对象中有一个属性constructor, 它指向函数对象2. 给原型对象添加属性(一般都是方法)  * 作用: 函数的所有实例对象自动拥有原型中的属性(方法)\r\n1. 函数的prototype属性(图)\r\n  * 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)\r\n  * 原型对象中有一个属性constructor, 它指向函数对象\r\n2. 给原型对象添加属性(一般都是方法)\r\n  * 作用: 函数的所有实例对象自动拥有原型中的属性(方法)"},"children":[{"data":{"id":"MID-17gvs1nri0ka1h7ssgpi1ao4n1","text":"1. 函数的protype属性"},"children":[{"data":{"id":"MID-1q4svbp889vpf9v56deplioko6","text":"undefined","image":"xap:resources/624eginv8dohtju4qo5ho36nga.png","imageSize":{"width":351,"height":50}},"children":[]}]},{"data":{"id":"MID-7mhjfgui67llbfbtpb1ejufgh5","text":"2. 给原型对象添加属性(一般都是方法)"},"children":[]}]},{"data":{"id":"MID-25ashabeujce6qtahfvjhmdcra","text":"显式原型与隐式原型","note":"1. 每个函数function都有一个prototype，即显式原型2. 每个实例对象都有一个__proto__，可称为隐式原型3. 对象的隐式原型的值为其对应构造函数的显式原型的值4. 内存结构(图)5. 总结:  * 函数的prototype属性: 在定义函数时自动添加的, 默认值是一个空Object对象  * 对象的__proto__属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值  * 程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之前)\r\n1. 每个函数function都有一个prototype，即显式原型\r\n2. 每个实例对象都有一个__proto__，可称为隐式原型\r\n3. 对象的隐式原型的值为其对应构造函数的显式原型的值\r\n4. 内存结构(图)\r\n5. 总结:\r\n  * 函数的prototype属性: 在定义函数时自动添加的, 默认值是一个空Object对象\r\n  * 对象的__proto__属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值\r\n  * 程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之前)"},"children":[{"data":{"id":"MID-7vd3vkobrou086gl304p01epv5","text":"","image":"xap:resources/1oda0cb3qud861uaaqg0gud9qq.png","imageSize":{"width":302,"height":169}},"children":[]}]},{"data":{"id":"MID-0a0gvk286ubm8n9ogcero48pm7","text":"原型链"},"children":[{"data":{"id":"MID-6btf9l157andmoteofg4k82fi4","text":"1. 原型链","note":"1. 原型链(图解)  * 访问一个对象的属性时，    * 先在自身属性中查找，找到返回    * 如果没有, 再沿着__proto__这条链向上查找, 找到返回    * 如果最终没找到, 返回undefined  * 别名: 隐式原型链  * 作用: 查找对象的属性(方法)2. 构造函数/原型/实体对象的关系(图解)3. 构造函数/原型/实体对象的关系2(图解)\r\n1. 原型链(图解)\r\n  * 访问一个对象的属性时，\r\n    * 先在自身属性中查找，找到返回\r\n    * 如果没有, 再沿着__proto__这条链向上查找, 找到返回\r\n    * 如果最终没找到, 返回undefined\r\n  * 别名: 隐式原型链\r\n  * 作用: 查找对象的属性(方法)\r\n2. 构造函数/原型/实体对象的关系(图解)\r\n3. 构造函数/原型/实体对象的关系2(图解)"},"children":[{"data":{"id":"MID-7nlgminpnjl7bkhk1ne9qb5k5l","text":"","image":"xap:resources/1iecdaba9mn03e2fnlvp10lm4t.png","imageSize":{"width":400,"height":178}},"children":[]}]},{"data":{"id":"MID-2fblqt8s97li3gq2at24rr89lh","text":"2. 构造函数/原型/实例对象的关系(图解)"},"children":[{"data":{"id":"MID-717geoglju4ajq827pbmsboksg","text":"var o1 = new Object();\r\nvar o2 = {};"},"children":[]},{"data":{"id":"MID-768drul07r0c7l19pfh0gkqiqp","text":""},"children":[]},{"data":{"id":"MID-7kgv5p1mr4gl7gsh16ld408928","text":"undefined","image":"xap:resources/28ihk0f7lfpfskogoa0mucc0fl.png","imageSize":{}},"children":[]}]},{"data":{"id":"MID-0mif6kg97q37u1gjturc70clbo","text":"3. 构造函数/原型/实例对象的关系2(图解)"},"children":[{"data":{"id":"MID-6s2nqcidpd1l5u835qj0nu2pg4","text":"function Foo(){  }"},"children":[]},{"data":{"id":"MID-0lqj2dep3rakakkk69ro4fi5ld","text":""},"children":[]},{"data":{"id":"MID-16ql0jh673qlgojn8vs9uj82sn","text":"undefined","image":"xap:resources/738hkjje9qtmicffmvo3vhpgc6.png","imageSize":{}},"children":[]}]},{"data":{"id":"MID-1t6qq2dsapd1n8aiftplr6vopo","text":"4. 原型继承"},"children":[{"data":{"id":"MID-6gq0gu99lgnn7suip9ugglpjtg","text":"构造函数的实例对象自动拥有构造函数原型对象的属性(方法)"},"children":[]},{"data":{"id":"MID-25f2u3rjgdoirgbh308laf573p","text":"利用的就是原型链"},"children":[]}]},{"data":{"id":"MID-3lqlcpd7adg896ngndgm5vf3h0","text":"5. 原型属性问题","note":"1. 读取对象的属性值时: 会自动到原型链中查找2. 设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值3. 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上\r\n1. 读取对象的属性值时: 会自动到原型链中查找\r\n2. 设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值\r\n3. 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上"},"children":[]}]},{"data":{"id":"MID-7oqr4kbibvsouid9kbp9ljd944","text":"探索instanceof","note":"1. instanceof是如何判断的?  * 表达式: A instanceof B  * 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false2. Function是通过new自己产生的实例\r\n1. instanceof是如何判断的?\r\n  * 表达式: A instanceof B\r\n  * 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false\r\n2. Function是通过new自己产生的实例"},"children":[{"data":{"id":"MID-6rdof7kqmt2nil4cfcnfu24qc5","text":"案例1"},"children":[{"data":{"id":"MID-7vlgj3e9569u8manj3536h0lv9","text":"function Foo() {  }\r\nvar f1 = new Foo();\r\nconsole.log(f1 instanceof Foo);\r\nconsole.log(f1 instanceof Object);"},"children":[]},{"data":{"id":"MID-6qavfoib8aset0dpavmtj2a0tv","text":""},"children":[]},{"data":{"id":"MID-4l4gpeulbh5rhvcgechognfc0s","text":"undefined","image":"xap:resources/4ih5i109mvc100klmdvkpbp5cj.png","imageSize":{}},"children":[]}]},{"data":{"id":"MID-7iht0s48k7rl330k4vff0p3b6l","text":"案例2"},"children":[{"data":{"id":"MID-1rva18ahtv4adt605gff21v6q0","text":"console.log(Object instanceof Function);\r\nconsole.log(Object instanceof Object);\r\nconsole.log(Function instanceof Function);\r\nconsole.log(Function instanceof Object);\r\n\r\nfunction Foo() {}\r\nconsole.log(Object instanceof  Foo);"},"children":[]},{"data":{"id":"MID-673m9v28ofvqkv69kbekcpur22","text":""},"children":[]},{"data":{"id":"MID-0ki1gr30c5dn84h6po64vpj73i","text":"undefined","image":"xap:resources/4saqd3oe3gi69eqkogj7sv12t0.png","imageSize":{}},"children":[]}]}]},{"data":{"id":"MID-0d0j5cj69ubarqr9blj8d4aah3","text":"面试题","note":"/*  测试题1   */  var A = function() {  }  A.prototype.n = 1  var b = new A()  A.prototype = {    n: 2,    m: 3  }  var c = new A()  console.log(b.n, b.m, c.n, c.m)  /*   测试题2   */  var F = function(){};  Object.prototype.a = function(){    console.log('a()')  };  Function.prototype.b = function(){    console.log('b()')  };  var f = new F();  f.a()  f.b()  F.a()  F.b()\r\n/*\r\n  测试题1\r\n   */\r\n  var A = function() {\r\n\r\n  }\r\n  A.prototype.n = 1\r\n\r\n  var b = new A()\r\n\r\n  A.prototype = {\r\n    n: 2,\r\n    m: 3\r\n  }\r\n\r\n  var c = new A()\r\n  console.log(b.n, b.m, c.n, c.m)\r\n\r\n\r\n  /*\r\n   测试题2\r\n   */\r\n  var F = function(){};\r\n  Object.prototype.a = function(){\r\n    console.log('a()')\r\n  };\r\n  Function.prototype.b = function(){\r\n    console.log('b()')\r\n  };\r\n  var f = new F();\r\n  f.a()\r\n  f.b()\r\n  F.a()\r\n  F.b()"},"children":[]}]},{"data":{"id":"MID-5866ighhefmvbhnfkc3u25ndrk","text":"执行上下文与执行上下文栈"},"children":[{"data":{"id":"MID-10ontcvkatl5tv7955lfu2gavr","text":"变量提升与函数提升","note":"1. 变量声明提升  * 通过var定义(声明)的变量, 在定义语句之前就可以访问到  * 值: undefined2. 函数声明提升  * 通过function声明的函数, 在之前就可以直接调用  * 值: 函数定义(对象)3. 问题: 变量提升和函数提升是如何产生的?\r\n1. 变量声明提升\r\n  * 通过var定义(声明)的变量, 在定义语句之前就可以访问到\r\n  * 值: undefined\r\n2. 函数声明提升\r\n  * 通过function声明的函数, 在之前就可以直接调用\r\n  * 值: 函数定义(对象)\r\n3. 问题: 变量提升和函数提升是如何产生的?"},"children":[]},{"data":{"id":"MID-123iea3brshbgpufc17a7anntm","text":"执行上下文","note":"1. 代码分类(位置)  * 全局代码  * 函数代码2. 全局执行上下文  * 在执行全局代码前将window确定为全局执行上下文  * 对全局数据进行预处理    * var定义的全局变量==>undefined, 添加为window的属性    * function声明的全局函数==>赋值(fun), 添加为window的方法    * this==>赋值(window)  * 开始执行全局代码3. 函数执行上下文  * 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象  * 对局部数据进行预处理    * 形参变量==>赋值(实参)==>添加为执行上下文的属性    * arguments==>赋值(实参列表), 添加为执行上下文的属性    * var定义的局部变量==>undefined, 添加为执行上下文的属性    * function声明的函数 ==>赋值(fun), 添加为执行上下文的方法    * this==>赋值(调用函数的对象)  * 开始执行函数体代码\r\n1. 代码分类(位置)\r\n  * 全局代码\r\n  * 函数代码\r\n2. 全局执行上下文\r\n  * 在执行全局代码前将window确定为全局执行上下文\r\n  * 对全局数据进行预处理\r\n    * var定义的全局变量==>undefined, 添加为window的属性\r\n    * function声明的全局函数==>赋值(fun), 添加为window的方法\r\n    * this==>赋值(window)\r\n  * 开始执行全局代码\r\n3. 函数执行上下文\r\n  * 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象\r\n  * 对局部数据进行预处理\r\n    * 形参变量==>赋值(实参)==>添加为执行上下文的属性\r\n    * arguments==>赋值(实参列表), 添加为执行上下文的属性\r\n    * var定义的局部变量==>undefined, 添加为执行上下文的属性\r\n    * function声明的函数 ==>赋值(fun), 添加为执行上下文的方法\r\n    * this==>赋值(调用函数的对象)\r\n  * 开始执行函数体代码"},"children":[{"data":{"id":"MID-340tgpaa83e28p6b2uumu7ua59","text":"1. 代码分类(位置)"},"children":[]},{"data":{"id":"MID-192vfafsjajcl1fr5kr876bin5","text":"2. 全局执行上下文"},"children":[]},{"data":{"id":"MID-2q920nbjj93uuv7768jnod797o","text":"3. 函数执行上下文"},"children":[]}]},{"data":{"id":"MID-1aajfm9f82fji43s2d791c0s7q","text":"执行上下文栈"},"children":[{"data":{"id":"MID-0r6p4flrvm5srioai9r6atqsc8","text":"理解","note":"1. 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象2. 在全局执行上下文(window)确定后, 将其添加到栈中(压栈)3. 在函数执行上下文创建后, 将其添加到栈中(压栈)4. 在当前函数执行完后,将栈顶的对象移除(出栈)5. 当所有的代码执行完后, 栈中只剩下window\r\n1. 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象\r\n2. 在全局执行上下文(window)确定后, 将其添加到栈中(压栈)\r\n3. 在函数执行上下文创建后, 将其添加到栈中(压栈)\r\n4. 在当前函数执行完后,将栈顶的对象移除(出栈)\r\n5. 当所有的代码执行完后, 栈中只剩下window"},"children":[]},{"data":{"id":"MID-22hhrungtsb57p01ihngt3ajln","text":"流程分析","note":" var a = 10  var bar = function (x) {    var b = 5    foo(x + b)                }  var foo = function (y) {    var c = 5    console.log(a + c + y)  }  bar(10)                   \r\n var a = 10\r\n  var bar = function (x) {\r\n    var b = 5\r\n    foo(x + b)              \r\n  }\r\n  var foo = function (y) {\r\n    var c = 5\r\n    console.log(a + c + y)\r\n  }\r\n  bar(10)                   "},"children":[{"data":{"id":"MID-0951lvjhik35eppie2a260e6u2","text":"undefined","image":"xap:resources/2bvqfin3qdbnd718pcban6gdie.png","imageSize":{}},"children":[]},{"data":{"id":"MID-0jrco9qlvmkrb348ko0n9rsaqk","text":""},"children":[]},{"data":{"id":"MID-75r0pj1aes526j01etjc5622bh","text":"undefined","image":"xap:resources/4joo7qg9rfrtvkqqe91g1jea0c.png","imageSize":{}},"children":[]},{"data":{"id":"MID-7udef4ssrlqhu21veu7qbgmk4j","text":""},"children":[]},{"data":{"id":"MID-1bf56u2kt3jjb1p0tv2dtm7bkv","text":"undefined","image":"xap:resources/3of06jasko5fig64gorbsl6th0.png","imageSize":{"width":295,"height":136}},"children":[]}]}]},{"data":{"id":"MID-1g5ee6s100e9olkn49gqjtmvf0","text":"面试题","note":" /*  测试题1:   */  function a() {}  var a;  console.log(typeof a)  /*  测试题2:    */  if (!(b in window)) {    var b = 1;  }  console.log(b)  /*  测试题3:    */  var c = 1  function c(c) {    console.log(c)    var c = 3  }  c(2)\r\n /*\r\n  测试题1: \r\n  */\r\n  function a() {}\r\n  var a;\r\n  console.log(typeof a)\r\n\r\n\r\n  /*\r\n  测试题2: \r\n   */\r\n  if (!(b in window)) {\r\n    var b = 1;\r\n  }\r\n  console.log(b)\r\n\r\n  /*\r\n  测试题3: \r\n   */\r\n  var c = 1\r\n  function c(c) {\r\n    console.log(c)\r\n    var c = 3\r\n  }\r\n  c(2)"},"children":[]}]},{"data":{"id":"MID-1335qs20hmphmrnd2pc8d1s53l","text":"作用域与作用域链"},"children":[{"data":{"id":"MID-6o6sflo20mnr0p3qbbtmj7n7gv","text":"作用域","note":"1. 理解  * 就是一块\"地盘\", 一个代码段所在的区域  * 它是静态的(相对于上下文对象), 在编写代码时就确定了2. 分类  * 全局作用域  * 函数作用域  * 没有块作用域(ES6有了)3. 作用  * 隔离变量，不同作用域下同名变量不会有冲突\r\n1. 理解\r\n  * 就是一块\"地盘\", 一个代码段所在的区域\r\n  * 它是静态的(相对于上下文对象), 在编写代码时就确定了\r\n2. 分类\r\n  * 全局作用域\r\n  * 函数作用域\r\n  * 没有块作用域(ES6有了)\r\n3. 作用\r\n  * 隔离变量，不同作用域下同名变量不会有冲突"},"children":[{"data":{"id":"MID-6jsl2sld0jct2c2b9hj4mt6o04","text":"undefined","image":"xap:resources/298c5hjjvafp95preq2c5tr7ba.png","imageSize":{}},"children":[]}]},{"data":{"id":"MID-2d7prfqgqfjrvbl6lf1erhtns6","text":"作用域与执行上下文","note":"1. 区别1  * 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时  * 全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建  * 函数执行上下文环境是在调用函数时, 函数体代码执行之前创建2. 区别2  * 作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化  * 上下文环境是动态的, 调用函数时创建, 函数调用结束时上下文环境就会被释放3. 联系  * 上下文环境(对象)是从属于所在的作用域  * 全局上下文环境==>全局作用域  * 函数上下文环境==>对应的函数使用域\r\n1. 区别1\r\n  * 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时\r\n  * 全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建\r\n  * 函数执行上下文环境是在调用函数时, 函数体代码执行之前创建\r\n2. 区别2\r\n  * 作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化\r\n  * 上下文环境是动态的, 调用函数时创建, 函数调用结束时上下文环境就会被释放\r\n3. 联系\r\n  * 上下文环境(对象)是从属于所在的作用域\r\n  * 全局上下文环境==>全局作用域\r\n  * 函数上下文环境==>对应的函数使用域"},"children":[{"data":{"id":"MID-329ge7fktk1jkt8fhi783gbp3a","text":"undefined","image":"xap:resources/1k7874pokdrnqqgl5cl3v04jn1.png","imageSize":{}},"children":[]}]},{"data":{"id":"MID-20gvp4agml5l2bf52n6bjmg6iu","text":"作用域链","note":"1. 理解  * 多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外)  * 查找变量时就是沿着作用域链来查找的2. 查找一个变量的查找规则  * 在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入2  * 在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入3  * 再次执行2的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常\r\n1. 理解\r\n  * 多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外)\r\n  * 查找变量时就是沿着作用域链来查找的\r\n2. 查找一个变量的查找规则\r\n  * 在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入2\r\n  * 在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入3\r\n  * 再次执行2的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常"},"children":[{"data":{"id":"MID-32q4trcqf8c3l0i9d48b362rf1","text":"undefined","note":"\tvar a = 2;    function fn1() {        var b = 3;        function fn2() {            var c = 4;            console.log(c);            console.log(b);            console.log(a);            console.log(d);        }        fn2();    }    fn1();\r\n\tvar a = 2;\r\n    function fn1() {\r\n        var b = 3;\r\n        function fn2() {\r\n            var c = 4;\r\n            console.log(c);\r\n            console.log(b);\r\n            console.log(a);\r\n            console.log(d);\r\n        }\r\n        fn2();\r\n    }\r\n    fn1();","image":"xap:resources/15appmobe0a99cbj4ra7o6uajt.png","imageSize":{}},"children":[]}]},{"data":{"id":"MID-1lqak5ggn9lep80fp47sc3ss0k","text":"面试题"},"children":[{"data":{"id":"MID-48il3bh0l5s22jj6dkqnv1q11m","text":"面试题1","note":"  var x = 10;  function fn() {    console.log(x);  }  function show(f) {    var x = 20;    f();  }  show(fn);\r\n  var x = 10;\r\n  function fn() {\r\n    console.log(x);\r\n  }\r\n  function show(f) {\r\n    var x = 20;\r\n    f();\r\n  }\r\n  show(fn);"},"children":[]},{"data":{"id":"MID-4cur7ockj82ql4bchusgum2ia6","text":"面试题2","note":"  var fn = function () {    console.log(fn)  }  fn()  var obj = {    fn2: function () {      console.log(fn2)    }  }  obj.fn2()\r\n  var fn = function () {\r\n    console.log(fn)\r\n  }\r\n  fn()\r\n\r\n  var obj = {\r\n    fn2: function () {\r\n      console.log(fn2)\r\n    }\r\n  }\r\n  obj.fn2()"},"children":[]}]}]},{"data":{"id":"MID-0n63uplgvg2qr6c9m62flpi6mq","text":"闭包"},"children":[{"data":{"id":"MID-3klt4njhu15ej03r9lrshehuvu","text":"引子实例","note":"<!DOCTYPE html><html lang=\"en\"><head>    <meta charset=\"UTF-8\">    <title>Title</title>    <script type=\"text/javascript\">          /*需求: 点击某个按钮, 提示\"点击的是第n个按钮\"         */    </script></head><body>    <button>测试1</button>    <button>测试2</button>    <button>测试3</button></body></html>\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Title</title>\r\n    <script type=\"text/javascript\">\r\n          /*\r\n需求: 点击某个按钮, 提示\"点击的是第n个按钮\"\r\n         */\r\n    </script>\r\n</head>\r\n<body>\r\n    <button>测试1</button>\r\n    <button>测试2</button>\r\n    <button>测试3</button>\r\n</body>\r\n\r\n</html>"},"children":[]},{"data":{"id":"MID-26qa87tkng368ika2oqgf1b5uc","text":"理解闭包","note":"1. 如何产生闭包?  * 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包2. 闭包到底是什么?  * 使用chrome调试查看  * 理解一: 闭包是嵌套的内部函数(绝大部分人)  * 理解二: 包含被引用变量(函数)的对象(极少数人)  * 注意: 闭包存在于嵌套的内部函数中3. 产生闭包的条件?  * 函数嵌套  * 内部函数引用了外部函数的数据(变量/函数)\r\n1. 如何产生闭包?\r\n  * 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包\r\n2. 闭包到底是什么?\r\n  * 使用chrome调试查看\r\n  * 理解一: 闭包是嵌套的内部函数(绝大部分人)\r\n  * 理解二: 包含被引用变量(函数)的对象(极少数人)\r\n  * 注意: 闭包存在于嵌套的内部函数中\r\n3. 产生闭包的条件?\r\n  * 函数嵌套\r\n  * 内部函数引用了外部函数的数据(变量/函数)"},"children":[]},{"data":{"id":"MID-7nbd47u5tvn639u7u1mrvlfq6e","text":"常见的闭包","note":"1. 将函数作为另一个函数的返回值2. 将函数作为实参传递给另一个函数调用\r\n1. 将函数作为另一个函数的返回值\r\n2. 将函数作为实参传递给另一个函数调用"},"children":[]},{"data":{"id":"MID-6lpb2la2qaprecha85rehf3lte","text":"闭包的作用","note":"1. 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)2. 让函数外部可以操作(读写)到函数内部的数据(变量/函数)问题:  1. 函数执行完后, 函数内部声明的局部变量是否还存在?  2. 在函数外部能直接访问函数内部的局部变量吗?\r\n1. 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)\r\n2. 让函数外部可以操作(读写)到函数内部的数据(变量/函数)\r\n\r\n问题:\r\n  1. 函数执行完后, 函数内部声明的局部变量是否还存在?\r\n  2. 在函数外部能直接访问函数内部的局部变量吗?"},"children":[]},{"data":{"id":"MID-7t40bnk6hpmg7p00h70hnu5jh0","text":"闭包的生命周期","note":"1. 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)2. 死亡: 在嵌套的内部函数成为垃圾对象时<script type=\"text/javascript\">  function fun1() {    //问题2: 此时闭包产生了吗?     var a = 3;    function fun2() {      a++;      console.log(a);    }    return fun2;  }  //问题1: 此时闭包产生了吗?     var f = fun1();  //问题3: 此时闭包释放了吗?    f();  f();  //问题4: 此时闭包释放回收了吗?     //问题5: 如何让闭包释放回收呢?</script>\r\n1. 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)\r\n2. 死亡: 在嵌套的内部函数成为垃圾对象时\r\n\r\n\r\n<script type=\"text/javascript\">\r\n  function fun1() {\r\n    //问题2: 此时闭包产生了吗? \r\n    var a = 3;\r\n\r\n    function fun2() {\r\n      a++;\r\n      console.log(a);\r\n    }\r\n\r\n    return fun2;\r\n  }\r\n  //问题1: 此时闭包产生了吗?   \r\n  var f = fun1();\r\n  //问题3: 此时闭包释放了吗?  \r\n  f();\r\n  f();\r\n  //问题4: 此时闭包释放回收了吗?   \r\n  //问题5: 如何让闭包释放回收呢?\r\n</script>"},"children":[]},{"data":{"id":"MID-6gffoubqc1dv57jl4f8cemcqfr","text":"闭包的应用: 自定义JS模块","note":"闭包的应用 : 定义JS模块  * 具有特定功能的js文件  * 将所有的数据和功能都封装在一个函数内部(私有的)  * 只向外暴露一个包信n个方法的对象或函数  * 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能\r\n闭包的应用 : 定义JS模块\r\n  * 具有特定功能的js文件\r\n  * 将所有的数据和功能都封装在一个函数内部(私有的)\r\n  * 只向外暴露一个包信n个方法的对象或函数\r\n  * 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能"},"children":[]},{"data":{"id":"MID-0hp773mk5scdfkvf335go0t2in","text":"闭包的缺点及解决","note":"1. 缺点  * 函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长  * 容易造成内存泄露2. 解决  * 能不用闭包就不用  * 及时释放\r\n1. 缺点\r\n  * 函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长\r\n  * 容易造成内存泄露\r\n2. 解决\r\n  * 能不用闭包就不用\r\n  * 及时释放"},"children":[]},{"data":{"id":"MID-14f5lt09nugu56fjqse756bcqs","text":"面试题"},"children":[{"data":{"id":"MID-23rdkrtjph3rmi7s09nkm0sqpr","text":"面试题一","note":"//代码片段一var name = \"The Window\";var object = {    name : \"My Object\",    getNameFunc : function(){        return function(){            return this.name;        };    }};alert(object.getNameFunc()());  //?//代码片段二var name2 = \"The Window\";var object2 = {    name2 : \"My Object\",    getNameFunc : function(){        var that = this;        return function(){            return that.name2;        };    }};alert(object2.getNameFunc()()); //?\r\n//代码片段一\r\nvar name = \"The Window\";\r\nvar object = {\r\n    name : \"My Object\",\r\n    getNameFunc : function(){\r\n        return function(){\r\n            return this.name;\r\n        };\r\n    }\r\n};\r\nalert(object.getNameFunc()());  //?\r\n\r\n\r\n//代码片段二\r\nvar name2 = \"The Window\";\r\nvar object2 = {\r\n    name2 : \"My Object\",\r\n    getNameFunc : function(){\r\n        var that = this;\r\n        return function(){\r\n            return that.name2;\r\n        };\r\n    }\r\n};\r\nalert(object2.getNameFunc()()); //?\r\n\r\n\r\n"},"children":[]},{"data":{"id":"MID-02pulcuq6aheq36npiebmvjmln","text":"面试题二","note":"  function fun(n,o) {        console.log(o)        return {            fun:function(m){                return fun(m,n);            }        };    }    var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?    var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?    var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?\r\n  function fun(n,o) {\r\n        console.log(o)\r\n        return {\r\n            fun:function(m){\r\n                return fun(m,n);\r\n            }\r\n        };\r\n    }\r\n    var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?\r\n    var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?\r\n    var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?"},"children":[]}]}]}]},{"data":{"id":"MID-1lsvoou43hfh05trbbbvpmrgkm","text":"面向对象高级","priority":3},"children":[{"data":{"id":"MID-6ufl0qoqvc3ehhc0ugsje2grj8","text":"对象创建模式"},"children":[{"data":{"id":"MID-0f5727ub6g7jjp7aj4notvcllr","text":"Object构造函数模式","note":"方式1: Object构造函数模式  * 套路: 先创建空Object对象, 再动态添加属性/方法  * 适用场景: 起始时不确定对象内部数据  * 问题: 语句太多\r\n方式1: Object构造函数模式\r\n  * 套路: 先创建空Object对象, 再动态添加属性/方法\r\n  * 适用场景: 起始时不确定对象内部数据\r\n  * 问题: 语句太多"},"children":[]},{"data":{"id":"MID-18sq1g7edk72ipdb23tju4nli3","text":"对象字面量模式","note":"方式2: 对象字面量模式  * 套路: 使用{}创建对象, 同时指定属性/方法  * 适用场景: 起始时对象内部数据是确定的  * 问题: 如果创建多个对象, 有重复代码\r\n方式2: 对象字面量模式\r\n  * 套路: 使用{}创建对象, 同时指定属性/方法\r\n  * 适用场景: 起始时对象内部数据是确定的\r\n  * 问题: 如果创建多个对象, 有重复代码"},"children":[]},{"data":{"id":"MID-51fnguc3961sd9qr2pt52cnkl0","text":"工厂模式","note":"方式3: 工厂模式  * 套路: 通过工厂函数动态创建对象并返回  * 适用场景: 需要创建多个对象  * 问题: 对象没有一个具体的类型, 都是Object类型\r\n方式3: 工厂模式\r\n  * 套路: 通过工厂函数动态创建对象并返回\r\n  * 适用场景: 需要创建多个对象\r\n  * 问题: 对象没有一个具体的类型, 都是Object类型"},"children":[]},{"data":{"id":"MID-41q7eujunrdomnkjb631fh25i1","text":"自定义构造函数模式","note":"方式4: 自定义构造函数模式  * 套路: 自定义构造函数, 通过new创建对象  * 适用场景: 需要创建多个类型确定的对象  * 问题: 每个对象都有相同的数据, 浪费内存\r\n方式4: 自定义构造函数模式\r\n  * 套路: 自定义构造函数, 通过new创建对象\r\n  * 适用场景: 需要创建多个类型确定的对象\r\n  * 问题: 每个对象都有相同的数据, 浪费内存"},"children":[]},{"data":{"id":"MID-42conblso10kqpfpercg03eetq","text":"构造函数+原型的组合模式","note":"方式5: 构造函数+原型的组合模式  * 套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上  * 适用场景: 需要创建多个类型确定的对象\r\n方式5: 构造函数+原型的组合模式\r\n  * 套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上\r\n  * 适用场景: 需要创建多个类型确定的对象"},"children":[]}]},{"data":{"id":"MID-1hcpjup1fi7tglerobm5ampdl4","text":"继承模式"},"children":[{"data":{"id":"MID-0dc7usa3ka24fdflvnf3qgcnhr","text":"原型链继承","note":"方式1: 原型链继承  1. 套路    1. 定义父类型构造函数    2. 给父类型的原型添加方法    3. 定义子类型的构造函数    4. 创建父类型的对象赋值给子类型的原型    5. 将子类型原型的构造属性设置为子类型    6. 给子类型原型添加方法    7. 创建子类型的对象: 可以调用父类型的方法  2. 关键    1. 子类型的原型为父类型的一个实例对象\r\n方式1: 原型链继承\r\n  1. 套路\r\n    1. 定义父类型构造函数\r\n    2. 给父类型的原型添加方法\r\n    3. 定义子类型的构造函数\r\n    4. 创建父类型的对象赋值给子类型的原型\r\n    5. 将子类型原型的构造属性设置为子类型\r\n    6. 给子类型原型添加方法\r\n    7. 创建子类型的对象: 可以调用父类型的方法\r\n  2. 关键\r\n    1. 子类型的原型为父类型的一个实例对象"},"children":[{"data":{"id":"MID-6eqma8drpfbv3d37l2p9rv7iav","text":"","image":"xap:resources/172hceh43o0sbne4ru1gm5sg2i.png","imageSize":{"width":400,"height":184}},"children":[]}]},{"data":{"id":"MID-4jkp25sch2tteapmr7dn56lunt","text":"借用构造函数继承","note":"方式2: 借用构造函数继承(假的)1. 套路:  1. 定义父类型构造函数  2. 定义子类型构造函数  3. 在子类型构造函数中调用父类型构造2. 关键:  1. 在子类型构造函数中通用super()调用父类型构造函数\r\n方式2: 借用构造函数继承(假的)\r\n1. 套路:\r\n  1. 定义父类型构造函数\r\n  2. 定义子类型构造函数\r\n  3. 在子类型构造函数中调用父类型构造\r\n2. 关键:\r\n  1. 在子类型构造函数中通用super()调用父类型构造函数"},"children":[]},{"data":{"id":"MID-640pqsthc1o9or8lgtc8of1oej","text":"组合继承","note":"方式3: 原型链+借用构造函数的组合继承1. 利用原型链实现对父类型对象的方法继承2. 利用super()借用父类型构建函数初始化相同属性\r\n方式3: 原型链+借用构造函数的组合继承\r\n1. 利用原型链实现对父类型对象的方法继承\r\n2. 利用super()借用父类型构建函数初始化相同属性"},"children":[]}]}]},{"data":{"id":"MID-2o026tu5tgalrkm3ta80fhgcf4","text":"线程机制与事件机制","priority":4},"children":[{"data":{"id":"MID-53t5oc4ep7i2bijq386pa91ifr","text":"进程与线程"},"children":[{"data":{"id":"MID-1b89lamhsdi3ps5i7pjvfk5n0j","text":"进程(process)"},"children":[{"data":{"id":"MID-6ll17utvuj82cuel69ldr46j1r","text":"程序的一次执行, 它占有一片独有的内存空间"},"children":[]},{"data":{"id":"MID-73jp3s2ethh914ng3lukuvu9rl","text":"可以通过windows任务管理器查看进程"},"children":[]}]},{"data":{"id":"MID-0aip2uhd81g8ihsa1ao8nuros0","text":"线程(thread)"},"children":[{"data":{"id":"MID-11f1li8rcve7rqnsgtms2qkdmr","text":"是进程内的一个独立执行单元"},"children":[]},{"data":{"id":"MID-2174keng621epbqh5bonl4gt23","text":"是程序执行的一个完整流程"},"children":[]},{"data":{"id":"MID-2isgcnsrtkcebchcvav1e742pg","text":" 是CPU的最小的调度单元"},"children":[]}]},{"data":{"id":"MID-4ogrgpkl248akcdda0vss5g155","text":"图解"},"children":[{"data":{"id":"MID-5o8cu2je0fhnbcthhkomdnsfc1","text":"undefined","image":"xap:resources/4feb8kfqj4ib8k0pn482o4p7dc.png","imageSize":{}},"children":[]}]},{"data":{"id":"MID-3oksg32p0tcf3nk4cgc5l266cr","text":"相关知识"},"children":[{"data":{"id":"MID-5hnptkv7bp8lme4u4a70pce4oa","text":"应用程序必须运行在某个进程的某个线程上"},"children":[]},{"data":{"id":"MID-1qp2uvku1277qvhfjfd758e74k","text":"一个进程中至少有一个运行的线程: 主线程,  进程启动后自动创建"},"children":[]},{"data":{"id":"MID-0j96dr173o8hhh52rpsg552vka","text":"一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的"},"children":[]},{"data":{"id":"MID-4vvuj1c17ru9qp6agv0e7s0tje","text":"一个进程内的数据可以供其中的多个线程直接共享"},"children":[]},{"data":{"id":"MID-419m285qrq14vogovrsqbe4mqo","text":"多个进程之间的数据是不能直接共享的"},"children":[]},{"data":{"id":"MID-3ok6pmu5cbcpu20tporopmaq2d","text":"线程池(thread pool): 保存多个线程对象的容器, 实现线程对象的反复利用"},"children":[]}]},{"data":{"id":"MID-5t2qb5vis03l8jcblkejgb9r5h","text":"相关问题"},"children":[{"data":{"id":"MID-467gs3fpk5rheop5eeqqkuuq0f","text":"何为多进程与多线程?"},"children":[{"data":{"id":"MID-5fmncu78ge1ios1mvq583pooob","text":"多进程运行: 一应用程序可以同时启动多个实例运行"},"children":[]},{"data":{"id":"MID-1drah7aoupotocrkgjsqgs9kal","text":"多线程: 在一个进程内, 同时有多个线程运行"},"children":[]}]},{"data":{"id":"MID-7ccffte64n0rlmg28c42jb3i2v","text":"比较单线程与多线程?"},"children":[{"data":{"id":"MID-33d97qdn4nh5sdp7bjc9i4pirf","text":"多线程"},"children":[{"data":{"id":"MID-0li6cq5pe82jeb9qolkuahcl1l","text":"优点"},"children":[{"data":{"id":"MID-2ofgn0iokcig8vjh1gkv17fugr","text":"能有效提升CPU的利用率"},"children":[]}]},{"data":{"id":"MID-53fjsu0avcf5o1l511g3pju391","text":"缺点"},"children":[{"data":{"id":"MID-67kmd5pesmrta8b4n9fu5lh63v","text":"创建多线程开销"},"children":[]},{"data":{"id":"MID-3rp2irmaaap71tlvq6eqjsbea4","text":"线程间切换开销"},"children":[]},{"data":{"id":"MID-18ppd5n3752de58v378k2c0v0f","text":"死锁与状态同步问题"},"children":[]}]}]},{"data":{"id":"MID-2frpj1u812agcg17q01gpmtl0t","text":"单线程"},"children":[{"data":{"id":"MID-7emgskt5mut0snu6f72ei2hqa6","text":"优点"},"children":[{"data":{"id":"MID-0kpge0nmhreatgcig04lrmsoip","text":"顺序编程简单易懂"},"children":[]}]},{"data":{"id":"MID-0odn5aimochk6a406iga60od1c","text":"缺点"},"children":[{"data":{"id":"MID-0e6nr0e08ula3n0q71siulmfk6","text":"效率低"},"children":[]}]}]}]},{"data":{"id":"MID-5u2f9dqptgdb4d30pallbqmqb2","text":"JS是单线程还是多线程?"},"children":[{"data":{"id":"MID-18go9jf0q5fd96brp1ap50nd3i","text":"js是单线程运行的"},"children":[]},{"data":{"id":"MID-2u43ijl030iia17ejjfi5kr3i8","text":"但使用H5中的 Web Workers可以多线程运行"},"children":[]}]},{"data":{"id":"MID-2p2vq82qs2dto7m9lkcuf3hn3q","text":"浏览器运行是单线程还是多线程?"},"children":[{"data":{"id":"MID-2c41oop9h8v0kgt3uf74o8f80q","text":"都是多线程运行的"},"children":[]}]},{"data":{"id":"MID-3v5hft1tkn30caclvdsuoadfpl","text":"浏览器运行是单进程还是多进程?"},"children":[{"data":{"id":"MID-09o2l6ie6mfjflfoqtp38nanqp","text":"有的是单进程"},"children":[{"data":{"id":"MID-5e9lv4uas9m1331uavkr9rphbc","text":"firefox"},"children":[]},{"data":{"id":"MID-22kbmc5v3hootbjag0mmephnqs","text":"老版IE"},"children":[]}]},{"data":{"id":"MID-2qv2rb2okrj35uu9kpa4bl32pn","text":"有的是多进程"},"children":[{"data":{"id":"MID-6ul1hg4bvu2q5v5c1gasc4qnfq","text":"chrome"},"children":[]},{"data":{"id":"MID-19415ic8qf7f5fc2ufcamnb0p9","text":"新版IE"},"children":[]}]},{"data":{"id":"MID-6mi5qcql9ccrk3v9lp643fbtaf","text":"如何查看浏览器是否是多进程运行的呢?"},"children":[{"data":{"id":"MID-2p5tsak3fg6ad1nn20r8r8qer5","text":"任务管理器-->进程"},"children":[]}]}]}]}]},{"data":{"id":"MID-7469gl1rhg7f454jf2bmrltpga","text":"浏览器内核"},"children":[{"data":{"id":"MID-3h8ok94dq1gf2ti0v44ai595qq","text":"支撑浏览器运行的最核心的程序"},"children":[]},{"data":{"id":"MID-75kl3jacas8sei1m7epd92knue","text":"不同的浏览器可能不一样"},"children":[{"data":{"id":"MID-4qrl5gkhig0642tg2lk6vvvvpj","text":"Chrome, Safari : webkit"},"children":[]},{"data":{"id":"MID-2tlf8h0e99ohjds5crl8si9km5","text":"firefox : Gecko"},"children":[]},{"data":{"id":"MID-1putrrr57946vl43hufm82s0v2","text":"IE\t: Trident"},"children":[]},{"data":{"id":"MID-1fsuj298lf62qo2ckk2jqo3mm2","text":"360,搜狗等国内浏览器: Trident + webkit"},"children":[]}]},{"data":{"id":"MID-4ulsv97m5b3hk76dtku1k1d123","text":"内核由很多模块组成"},"children":[{"data":{"id":"MID-7pc1pnns97q8jirj4agfafbqn9","text":"js引擎模块 : 负责js程序的编译与运行"},"children":[]},{"data":{"id":"MID-23vep0q3llib5gfac9q0k094on","text":"html,css文档解析模块 : 负责页面文本的解析"},"children":[]},{"data":{"id":"MID-1983hinimcku54sn3h6kqv3m78","text":"DOM/CSS模块 : 负责dom/css在内存中的相关处理 "},"children":[]},{"data":{"id":"MID-19rs1v4iplc3dmtu9gecnkqq21","text":"布局和渲染模块 : 负责页面的布局和效果的绘制(内存中的对象)"},"children":[]},{"data":{"id":"MID-3a01i5ss1o6k57ga41dt0dv431","text":"......"},"children":[]},{"data":{"id":"MID-56dqcfe0ee0o9j7l8plsu2njmc","text":"定时器模块 : 负责定时器的管理"},"children":[]},{"data":{"id":"MID-6ijtnif97d174p7cieqljrgkt3","text":"DOM事件响应模块 : 负责事件的管理"},"children":[]},{"data":{"id":"MID-4161hqcjbd2k38ue71raad6ql8","text":"网络请求模块 : 负责ajax请求"},"children":[]},{"data":{"id":"MID-0g92kugnp4v5g72q9c2gb7kik7","text":"主线程"},"children":[]},{"data":{"id":"MID-3t5f5bns11g5oihappphbem9l7","text":"分线程"},"children":[]}]}]},{"data":{"id":"MID-1h8i30t0il8bok62vkct6gugs6","text":"定时器引发的思考","note":"1. 定时器真是定时执行的吗?  * 定时器并不能保证真正定时执行  * 一般会延迟一丁点(可以接受), 也有可能延迟很长时间(不能接受)2. 定时器回调函数是在分线程执行的吗?  * 在主线程执行的, js是单线程的3. 定时器是如何实现的?  * 事件循环模型(后面讲)\r\n1. 定时器真是定时执行的吗?\r\n  * 定时器并不能保证真正定时执行\r\n  * 一般会延迟一丁点(可以接受), 也有可能延迟很长时间(不能接受)\r\n2. 定时器回调函数是在分线程执行的吗?\r\n  * 在主线程执行的, js是单线程的\r\n3. 定时器是如何实现的?\r\n  * 事件循环模型(后面讲)"},"children":[{"data":{"id":"MID-3v6ptkekaonv2ois7eptjjt0fu","text":"1. 定时器真是定时执行的吗?"},"children":[]},{"data":{"id":"MID-2njhot6p47t7me2qia81vlf9qo","text":"2. 定时器回调函数是在哪个线程执行的?"},"children":[]},{"data":{"id":"MID-32su88jng2facmlhm37kbb33l0","text":"3. 定时器是如何实现的?"},"children":[]}]},{"data":{"id":"MID-0lh1nbovanre5fip28ba9bv4fh","text":"JS是单线程执行的","note":"1. 如何证明js执行是单线程的?  * setTimeout()的回调函数是在主线程执行的  * 定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行2. 为什么js要用单线程模式, 而不用多线程模式?  * JavaScript的单线程，与它的用途有关。  * 作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。  * 这决定了它只能是单线程，否则会带来很复杂的同步问题3. 代码的分类:  * 初始化代码  * 回调代码4. js引擎执行代码的基本流程  * 先执行初始化代码: 包含一些特别的代码    * 设置定时器    * 绑定监听    * 发送ajax请求  * 后面在某个时刻才会执行回调代码\r\n1. 如何证明js执行是单线程的?\r\n  * setTimeout()的回调函数是在主线程执行的\r\n  * 定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行\r\n2. 为什么js要用单线程模式, 而不用多线程模式?\r\n  * JavaScript的单线程，与它的用途有关。\r\n  * 作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。\r\n  * 这决定了它只能是单线程，否则会带来很复杂的同步问题\r\n\r\n3. 代码的分类:\r\n  * 初始化代码\r\n  * 回调代码\r\n4. js引擎执行代码的基本流程\r\n  * 先执行初始化代码: 包含一些特别的代码\r\n    * 设置定时器\r\n    * 绑定监听\r\n    * 发送ajax请求\r\n  * 后面在某个时刻才会执行回调代码"},"children":[{"data":{"id":"MID-18mtbt145jv6qo3evgojnr6rqa","text":"1. 如何证明js执行是单线程的?"},"children":[]},{"data":{"id":"MID-1o28a2i6odvqkhm61djh1q9n55","text":"2. 为什么js要用单线程模式, 而不用多线程模式?"},"children":[]},{"data":{"id":"MID-3e7s1ce10jo0vnav1ovcvhpbt7","text":"3. 代码的分类"},"children":[]},{"data":{"id":"MID-4r15pem6a7p4tvr4a1pb9352ec","text":"4. js引擎执行代码的基本流程"},"children":[]}]},{"data":{"id":"MID-0p140smlte8qr8ms6v28j6hhsh","text":"浏览器的事件循环(轮询)模型","note":"1. 所有代码分类  * 初始化执行代码: 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码  * 回调执行代码: 处理回调逻辑2. js引擎执行代码的基本流程:  * 初始化代码===>回调代码3. 模型的2个重要组成部分:  * 事件管理模块  * 回调队列4. 模型的运转流程  * 执行初始化代码, 将事件回调函数交给对应模块管理  * 当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中  * 只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行\r\n1. 所有代码分类\r\n  * 初始化执行代码: 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码\r\n  * 回调执行代码: 处理回调逻辑\r\n2. js引擎执行代码的基本流程:\r\n  * 初始化代码===>回调代码\r\n3. 模型的2个重要组成部分:\r\n  * 事件管理模块\r\n  * 回调队列\r\n4. 模型的运转流程\r\n  * 执行初始化代码, 将事件回调函数交给对应模块管理\r\n  * 当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中\r\n  * 只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行"},"children":[{"data":{"id":"MID-43ee0uprm8s11jf1iapc30a3dn","text":"模型原理图"},"children":[{"data":{"id":"MID-6ojoj8u26ae0btvm2cgmflar9f","text":"undefined","image":"xap:resources/4g9pbnpi4900p34f6s2dnuhee3.png","imageSize":{"width":364,"height":316}},"children":[]}]},{"data":{"id":"MID-6oqideo21s6n3dhrrcsv6une78","text":"相关重要概念","note":"1. 执行栈     execution stack     所有的代码都是在此空间中执行的 2. 浏览器内核     browser core     js引擎模块(在主线程处理)     其它模块(在主/分线程处理) 3. 任务队列(callback queue)     task queue 4. 消息队列(callback queue)     message queue 5. 事件队列(callback queue)     event queue 6. 事件轮询     event loop     从任务队列中循环取出回调函数放入执行栈中处理(一个接一个) 7. 事件驱动模型     event-driven interaction model 8. 请求响应模型     request-response model\r\n1. 执行栈\r\n     execution stack\r\n     所有的代码都是在此空间中执行的\r\n 2. 浏览器内核\r\n     browser core\r\n     js引擎模块(在主线程处理)\r\n     其它模块(在主/分线程处理)\r\n 3. 任务队列(callback queue)\r\n     task queue\r\n 4. 消息队列(callback queue)\r\n     message queue\r\n 5. 事件队列(callback queue)\r\n     event queue\r\n 6. 事件轮询\r\n     event loop\r\n     从任务队列中循环取出回调函数放入执行栈中处理(一个接一个)\r\n 7. 事件驱动模型\r\n     event-driven interaction model\r\n 8. 请求响应模型\r\n     request-response model"},"children":[{"data":{"id":"MID-4iubbepdakmis8hh83pb04f8b3","text":"1. 执行栈"},"children":[{"data":{"id":"MID-7eckp7dodpc1s3t51i8g4iv7o0","text":"execution stack"},"children":[]},{"data":{"id":"MID-5p280drpfsqotg38iedhii36l5","text":"所有的代码都是在此空间中执行的"},"children":[]}]},{"data":{"id":"MID-2puit9v2tkqjsqrl0npusdldim","text":"2. 浏览器内核"},"children":[{"data":{"id":"MID-08rereur5p7l22hso7ochbe2na","text":"browser core"},"children":[]},{"data":{"id":"MID-33n8jnjucasi93vv8g41hk5man","text":"js引擎模块(在主线程处理)"},"children":[]},{"data":{"id":"MID-515dl94lqdvbvkrsb34mq7rvu2","text":"其它模块(在主/分线程处理)"},"children":[]}]},{"data":{"id":"MID-15ccpu70knik4bsqsib8tlr6f6","text":"3. 任务队列"},"children":[{"data":{"id":"MID-25jquin5kijj5hkq606suf9fda","text":"task queue"},"children":[]}]},{"data":{"id":"MID-7knh46i4om4simdm1nfv25smp7","text":"4. 消息队列"},"children":[{"data":{"id":"MID-6f8a6nqtojmob0og8ojib2mf6s","text":"message queue"},"children":[]}]},{"data":{"id":"MID-6dvd265mg1pt5lvdeihm5392sc","text":"5. 事件队列"},"children":[{"data":{"id":"MID-2ti91dmso7c2cj8tc7u0pdq45b","text":"event queue"},"children":[]}]},{"data":{"id":"MID-4f8tao1egaik763ge43gg9hjps","text":"6. 事件轮询"},"children":[{"data":{"id":"MID-4arqksvs5raa5vq2iq6693ohn4","text":"event loop"},"children":[]},{"data":{"id":"MID-1vv2kq10h3ib4q1ei8hufdtemh","text":"从任务队列中循环取出回调函数放入执行栈中处理(一个接一个)"},"children":[]}]},{"data":{"id":"MID-49sh1i71po94npd9bu9263v5t3","text":"7. 事件驱动模型"},"children":[{"data":{"id":"MID-7ouejt04l2hi3qoloi5fnd9r5h","text":"event-driven interaction model"},"children":[]}]},{"data":{"id":"MID-1r71ahcf9so49bqhko4c3925nf","text":"8. 请求响应模型"},"children":[{"data":{"id":"MID-25jham5opqv4d57na3t1gglej0","text":"request-response model"},"children":[]}]},{"data":{"id":"MID-77mll67vivkreuc8jio19sn6qv","text":"同一个: callback queue"},"children":[]}]},{"data":{"id":"MID-6smq32f891lpd41j65liq61mu6","text":"执行流程"},"children":[]}]},{"data":{"id":"MID-3p686hgjh6v271nie3iv8vbg6g","text":"H5 Web Workers(多线程)"},"children":[{"data":{"id":"MID-7i8lfa7a6d1uskclosnrhohhrs","text":"介绍"},"children":[{"data":{"id":"MID-59rthb3kdk8u03lalfb10s5jdf","text":"Web Workers 是 HTML5 提供的一个javascript多线程解决方案"},"children":[]},{"data":{"id":"MID-0i3gdokq7mbbotdjkma1n2kh7l","text":"我们可以将一些大计算量的代码交由web Worker运行而不冻结用户界面"},"children":[]},{"data":{"id":"MID-4s7puhsjvqq4pak70mreeaf8dn","text":"但是子线程完全受主线程控制，且不得操作DOM。\r\n所以，这个新标准并没有改变JavaScript单线程的本质"},"children":[]}]},{"data":{"id":"MID-52qk5jjt84lm34h5aat151vv46","text":"使用"},"children":[{"data":{"id":"MID-7rqu7k8v9kqhj0jpc40q5vfesp","text":"创建在分线程执行的js文件","note":"var onmessage =function (event){ //不能用函数声明    console.log('onMessage()22');    var upper = event.data.toUpperCase();//通过event.data获得发送来的数据    postMessage( upper );//将获取到的数据发送会主线程}\r\nvar onmessage =function (event){ //不能用函数声明\r\n    console.log('onMessage()22');\r\n    var upper = event.data.toUpperCase();//通过event.data获得发送来的数据\r\n    postMessage( upper );//将获取到的数据发送会主线程\r\n}"},"children":[]},{"data":{"id":"MID-1910n02pi0j48g13ctjbtn10ta","text":"在主线程中的js中发消息并设置回调","note":"//创建一个Worker对象并向它传递将在新线程中执行的脚本的URLvar worker = new Worker(\"worker.js\");  //接收worker传过来的数据函数worker.onmessage = function (event) {         console.log(event.data);             };//向worker发送数据worker.postMessage(\"hello world\");    \r\n//创建一个Worker对象并向它传递将在新线程中执行的脚本的URL\r\nvar worker = new Worker(\"worker.js\");  \r\n//接收worker传过来的数据函数\r\nworker.onmessage = function (event) {     \r\n    console.log(event.data);             \r\n};\r\n//向worker发送数据\r\nworker.postMessage(\"hello world\");    "},"children":[]}]},{"data":{"id":"MID-64ah4narai752tdladcs536576","text":"图解"},"children":[{"data":{"id":"MID-4psark5u2vs14hm5v5cgvhohio","text":"","image":"xap:resources/41oe5l54jm3qq4782q8057u3mn.png","imageSize":{"width":400,"height":164}},"children":[]}]},{"data":{"id":"MID-5ivn6lc10mucfl8v5jcjj9o81i","text":"应用练习","note":"编程实现斐波那契数列（Fibonacci sequence）的计算F（0）=0，F（1）=1，..... F（n）=F(n-1)+F(n-2)\r\n编程实现斐波那契数列（Fibonacci sequence）的计算\r\nF（0）=0，F（1）=1，..... F（n）=F(n-1)+F(n-2)"},"children":[{"data":{"id":"MID-0u90n8ei9b406u7renos22shqe","text":"直接在主线程","note":"var fibonacci =function(n) {    return n <2 ? n : fibonacci(n -1) + fibonacci(n -2);};console.log(fibonacci(48));\r\nvar fibonacci =function(n) {\r\n    return n <2 ? n : fibonacci(n -1) + fibonacci(n -2);\r\n};\r\nconsole.log(fibonacci(48));"},"children":[]},{"data":{"id":"MID-4m8sd34lj4itvaro9g76eijohm","text":"使用Worker在分线程"},"children":[{"data":{"id":"MID-78m1d1rehvilvjfb3sgfe86750","text":"主线程","note":"var worker = new Worker('worker2.js');worker.addEventListener('message', function (event) {    var timer2 = new Date().getTime();    console.log('结果：' + event.data, '时间:' + timer2, '用时：' + ( timer2 - timer ));}, false);var timer = new Date().getTime();console.log('开始计算: ', '时间:' + timer);setTimeout(function () {    console.log('定时器函数在计算数列时执行了', '时间:' + new Date().getTime());}, 1000);worker.postMessage(40);console.log('我在计算数列的时候执行了', '时间:' + new Date().getTime());\r\nvar worker = new Worker('worker2.js');\r\nworker.addEventListener('message', function (event) {\r\n    var timer2 = new Date().getTime();\r\n    console.log('结果：' + event.data, '时间:' + timer2, '用时：' + ( timer2 - timer ));\r\n}, false);\r\n\r\nvar timer = new Date().getTime();\r\nconsole.log('开始计算: ', '时间:' + timer);\r\nsetTimeout(function () {\r\n    console.log('定时器函数在计算数列时执行了', '时间:' + new Date().getTime());\r\n}, 1000);\r\n\r\nworker.postMessage(40);\r\nconsole.log('我在计算数列的时候执行了', '时间:' + new Date().getTime());"},"children":[]},{"data":{"id":"MID-73nf2mpcutrdd0kribh0ca384h","text":"分线程","note":"var fibonacci =function(n) {    return n <2 ? n : fibonacci(n -1) + fibonacci(n -2);};var onmessage = function(event) {    var n = parseInt(event.data, 10);    postMessage(fibonacci(n));};\r\nvar fibonacci =function(n) {\r\n    return n <2 ? n : fibonacci(n -1) + fibonacci(n -2);\r\n};\r\n\r\nvar onmessage = function(event) {\r\n    var n = parseInt(event.data, 10);\r\n    postMessage(fibonacci(n));\r\n};"},"children":[]}]}]},{"data":{"id":"MID-1jpd3biddbb36ouv8kg8l944m9","text":"不足","note":"1. 慢1. 不能跨域加载JS2. worker内代码不能访问DOM(更新UI)3. 不是每个浏览器都支持这个新特性\r\n1. 慢\r\n1. 不能跨域加载JS\r\n2. worker内代码不能访问DOM(更新UI)\r\n3. 不是每个浏览器都支持这个新特性"},"children":[]}]}]}]}}